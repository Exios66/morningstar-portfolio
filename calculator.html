<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Data Visualization Calculator - Lucius Morningstar</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <!-- Add Chart.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.css">
    <style>
        :root {
            --primary-color: #ff00ff;
            --secondary-color: #00ffff;
            --background-color: #000033;
            --text-color: #ffffff;
            --container-bg: rgba(0, 0, 0, 0.7);
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            background-image: 
                linear-gradient(45deg, #ff00ff 25%, transparent 25%),
                linear-gradient(-45deg, #ff00ff 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ff00ff 75%),
                linear-gradient(-45deg, transparent 75%, #ff00ff 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--container-bg);
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            box-shadow: 0 0 20px var(--primary-color);
        }

        h1 {
            text-align: center;
            color: var(--secondary-color);
            text-shadow: 2px 2px var(--primary-color);
            font-size: 2.5em;
            margin-bottom: 30px;
        }

        label, select, input, button {
            display: block;
            width: 100%;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
        }

        select, input[type="file"], input[type="text"] {
            background-color: rgba(0, 0, 0, 0.5);
            color: var(--text-color);
            border: 1px solid var(--secondary-color);
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 10px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            outline: none;
            border-radius: 5px;
            margin-top: 10px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--text-color);
            cursor: pointer;
            border-radius: 50%;
        }

        button {
            background-color: var(--primary-color);
            color: var(--text-color);
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 16px;
        }

        button:hover {
            background-color: var(--secondary-color);
            transform: scale(1.05);
        }

        .chart-container {
            position: relative;
            margin: auto;
            height: 80vh;
            width: 80vw;
        }

        .filters {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin-top: 20px;
        }

        .filters label {
            display: inline-flex;
            align-items: center;
            color: var(--secondary-color);
            margin: 5px;
        }

        .filters input[type="checkbox"] {
            margin-right: 5px;
        }

        @keyframes neon-glow {
            0% {
                opacity: 0.5;
            }
            100% {
                opacity: 1;
            }
        }

        h1, button {
            animation: neon-glow 1.5s ease-in-out infinite alternate;
        }

        #results {
            margin-top: 20px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--secondary-color);
            border-radius: 5px;
            white-space: pre-wrap;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .filters {
                flex-direction: column;
            }
        }

        /* Add styles for file input */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
        }

        .file-input-wrapper .btn {
            display: inline-block;
            padding: 8px 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <header class="page-header">
        <div class="container">
            <h1>Advanced Data Visualization Calculator</h1>
            <nav>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="index.html#about">About</a></li>
                    <li><a href="index.html#services">Services</a></li>
                    <li><a href="index.html#projects">Projects</a></li>
                    <li><a href="index.html#contact">Contact</a></li>
                    <li><a href="index.html" class="active">Calculator</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <div class="container">
        <div class="file-input-wrapper">
            <button class="btn" type="button" onclick="document.getElementById('fileUpload').click()" aria-label="Choose CSV File">
                Choose CSV File
            </button>
            <input type="file" id="fileUpload" accept=".csv" onchange="processCSV(event)" aria-label="Upload CSV file">
            <div id="fileStatus" aria-live="polite"></div>
        </div>

        <label for="analysisType">Select the Statistical Analysis:</label>
        <select id="analysisType" onchange="updateUI()">
            <option value="basic">Basic Descriptive Statistics</option>
            <option value="skewness">Skewness and Kurtosis</option>
            <option value="cronbach">Cronbach's Alpha (Reliability)</option>
            <option value="correlation">Correlation Coefficient (Pearson's r)</option>
            <option value="ttest">T-Test (Compare Two Groups)</option>
            <option value="anova">ANOVA (Analysis of Variance)</option>
            <option value="regression">Linear Regression Analysis</option>
            <option value="chisquare">Chi-Square Test</option>
            <option value="factoranalysis">Factor Analysis</option>
            <option value="mannwhitney">Mann-Whitney U Test</option>
            <option value="cluster">Cluster Analysis</option>
        </select>

        <label for="chartType">Select Chart Type:</label>
        <select id="chartType" onchange="updateChart()">
            <option value="bar">Bar Chart</option>
            <option value="line">Line Chart</option>
            <option value="pie">Pie Chart</option>
            <option value="doughnut">Doughnut Chart</option>
            <option value="radar">Radar Chart</option>
            <option value="polarArea">Polar Area Chart</option>
            <option value="scatter">Scatter Plot</option>
            <option value="bubble">Bubble Chart</option>
        </select>

        <div id="dynamicInputs"></div>

        <button onclick="runAnalysis()">Run Analysis</button>

        <div class="filters" id="filterContainer"></div>

        <div id="results"></div>
    </div>

    <div class="chart-container">
        <canvas id="chartCanvas"></canvas>
    </div>

    <button onclick="exportResults()">Export Results</button>

    <footer role="contentinfo">
        <div class="container">
            <p>&copy; 2024 Copyright Morningstar Developments LLC. All rights reserved.</p>
            <nav class="footer-nav">
                <ul>
                    <li><a href="privacy-policy.html">Privacy Policy</a></li>
                    <li><a href="terms-of-service.html">Terms of Service</a></li>
                    <li><a href="sitemap.html">Sitemap</a></li>
                    <li><a href="https://morningstar-developments.notion.site/" target="_blank" rel="noopener noreferrer">Notion Page</a></li>
                    <li><a href="calculator.html">Calculator</a></li>
                </ul>
            </nav>
        </div>
    </footer>

    <!-- Update script sources -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.5.1/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script>
        let chart;
        let data = [];

        function processCSV(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                data = Papa.parse(text, { header: true, dynamicTyping: true }).data;
                updateUI();
                updateFileStatus(`File loaded: ${file.name}`);
            };
            reader.readAsText(file);
        }

        function updateUI() {
            const analysisType = document.getElementById('analysisType').value;
            const dynamicInputs = document.getElementById('dynamicInputs');
            dynamicInputs.innerHTML = '';

            if (data.length === 0) {
                dynamicInputs.innerHTML = '<p>Please upload a CSV file first.</p>';
                return;
            }

            const columns = Object.keys(data[0]);

            switch (analysisType) {
                case 'basic':
                    addColumnSelector('Select column for analysis:', 'columnSelect');
                    break;
                case 'ttest':
                case 'mannwhitney':
                    addColumnSelector('Select group column:', 'groupColumn');
                    addColumnSelector('Select value column:', 'valueColumn');
                    break;
                case 'anova':
                    addColumnSelector('Select group column:', 'groupColumn');
                    addColumnSelector('Select value column:', 'valueColumn');
                    break;
                case 'correlation':
                case 'regression':
                    addColumnSelector('Select X variable:', 'xVariable');
                    addColumnSelector('Select Y variable:', 'yVariable');
                    break;
                case 'chisquare':
                    addColumnSelector('Select first categorical variable:', 'variable1');
                    addColumnSelector('Select second categorical variable:', 'variable2');
                    break;
                case 'factoranalysis':
                case 'cluster':
                    addMultiColumnSelector('Select variables for analysis:', 'variablesSelect');
                    break;
            }
        }

        function addColumnSelector(labelText, id) {
            const dynamicInputs = document.getElementById('dynamicInputs');
            const label = document.createElement('label');
            label.htmlFor = id;
            label.textContent = labelText;

            const select = document.createElement('select');
            select.id = id;
            
            Object.keys(data[0]).forEach(column => {
                const option = document.createElement('option');
                option.value = column;
                option.textContent = column;
                select.appendChild(option);
            });

            dynamicInputs.appendChild(label);
            dynamicInputs.appendChild(select);
        }

        function addMultiColumnSelector(labelText, id) {
            const dynamicInputs = document.getElementById('dynamicInputs');
            const label = document.createElement('label');
            label.htmlFor = id;
            label.textContent = labelText;

            const select = document.createElement('select');
            select.id = id;
            select.multiple = true;
            
            Object.keys(data[0]).forEach(column => {
                const option = document.createElement('option');
                option.value = column;
                option.textContent = column;
                select.appendChild(option);
            });

            dynamicInputs.appendChild(label);
            dynamicInputs.appendChild(select);
        }

        function runAnalysis() {
            const analysisType = document.getElementById('analysisType').value;
            let results;

            switch (analysisType) {
                case 'basic':
                    results = calculateBasicStats();
                    break;
                case 'ttest':
                    results = performTTest();
                    break;
                case 'anova':
                    results = performANOVA();
                    break;
                case 'correlation':
                    results = calculateCorrelation();
                    break;
                case 'regression':
                    results = performRegression();
                    break;
                case 'chisquare':
                    results = performChiSquareTest();
                    break;
                case 'factoranalysis':
                    results = performFactorAnalysis();
                    break;
                case 'mannwhitney':
                    results = performMannWhitneyTest();
                    break;
                case 'cluster':
                    results = performClusterAnalysis();
                    break;
                default:
                    results = "Analysis not implemented yet.";
            }

            document.getElementById('results').textContent = JSON.stringify(results, null, 2);
            updateChart(results, analysisType);
        }

        function calculateBasicStats() {
            const column = document.getElementById('columnSelect').value;
            const numericData = data.map(row => row[column]).filter(val => typeof val === 'number' && !isNaN(val));
            const sortedData = [...numericData].sort((a, b) => a - b);
            const n = numericData.length;

            return {
                mean: math.mean(numericData),
                median: math.median(numericData),
                mode: math.mode(numericData),
                variance: math.variance(numericData),
                standardDeviation: math.std(numericData),
                skewness: calculateSkewness(numericData),
                kurtosis: calculateKurtosis(numericData),
                min: Math.min(...numericData),
                max: Math.max(...numericData),
                range: Math.max(...numericData) - Math.min(...numericData),
                q1: calculateQuantile(sortedData, 0.25),
                q3: calculateQuantile(sortedData, 0.75),
                iqr: calculateQuantile(sortedData, 0.75) - calculateQuantile(sortedData, 0.25),
                coefficientOfVariation: (math.std(numericData) / math.mean(numericData)) * 100,
                standardError: math.std(numericData) / Math.sqrt(n),
                confidenceInterval95: calculateConfidenceInterval(numericData, 0.95),
            };
        }

        function calculateSkewness(data) {
            const n = data.length;
            const mean = math.mean(data);
            const s = math.std(data);
            const skew = (1 / n) * data.reduce((sum, val) => sum + Math.pow((val - mean) / s, 3), 0);
            return skew;
        }

        function calculateKurtosis(data) {
            const n = data.length;
            const mean = math.mean(data);
            const s = math.std(data);
            const kurt = (1 / n) * data.reduce((sum, val) => sum + Math.pow((val - mean) / s, 4), 0) - 3;
            return kurt;
        }

        function calculateQuantile(sortedData, q) {
            const pos = (sortedData.length - 1) * q;
            const base = Math.floor(pos);
            const rest = pos - base;
            if (sortedData[base + 1] !== undefined) {
                return sortedData[base] + rest * (sortedData[base + 1] - sortedData[base]);
            } else {
                return sortedData[base];
            }
        }

        function calculateConfidenceInterval(data, confidence) {
            const n = data.length;
            const mean = math.mean(data);
            const stdError = math.std(data) / Math.sqrt(n);
            const tScore = jstat.studentt.inv((1 + confidence) / 2, n - 1);
            const margin = tScore * stdError;
            return [mean - margin, mean + margin];
        }

        function performShapiroWilkTest(data) {
            // This is a simplified version. For a full implementation, consider using a statistical library.
            const n = data.length;
            if (n < 3 || n > 5000) {
                return "Sample size must be between 3 and 5000 for Shapiro-Wilk test";
            }
            // ... (implement full Shapiro-Wilk algorithm)
            return { statistic: 0, pValue: 0 }; // Placeholder
        }

        function calculateZScores(data) {
            const mean = math.mean(data);
            const std = math.std(data);
            return data.map(val => (val - mean) / std);
        }

        function performTTest() {
            const groupColumn = document.getElementById('groupColumn').value;
            const valueColumn = document.getElementById('valueColumn').value;
            const groups = [...new Set(data.map(row => row[groupColumn]))];
            
            if (groups.length !== 2) {
                return "T-test requires exactly two groups.";
            }

            const group1 = data.filter(row => row[groupColumn] === groups[0]).map(row => row[valueColumn]);
            const group2 = data.filter(row => row[groupColumn] === groups[1]).map(row => row[valueColumn]);

            const n1 = group1.length;
            const n2 = group2.length;
            const mean1 = math.mean(group1);
            const mean2 = math.mean(group2);
            const var1 = math.variance(group1);
            const var2 = math.variance(group2);

            const pooledSE = Math.sqrt(var1/n1 + var2/n2);
            const tValue = (mean1 - mean2) / pooledSE;
            const df = n1 + n2 - 2;
            const pValue = 2 * (1 - jstat.studentt.cdf(Math.abs(tValue), df));

            const cohensD = (mean1 - mean2) / Math.sqrt((var1 + var2) / 2);

            return {
                tValue: tValue,
                pValue: pValue,
                degreesOfFreedom: df,
                cohensD: cohensD,
                confidenceInterval95: calculateConfidenceInterval([...group1, ...group2], 0.95),
                group1Statistics: calculateBasicStats(group1),
                group2Statistics: calculateBasicStats(group2)
            };
        }

        function performANOVA() {
            const groupColumn = document.getElementById('groupColumn').value;
            const valueColumn = document.getElementById('valueColumn').value;
            const groups = [...new Set(data.map(row => row[groupColumn]))];
            
            const groupData = groups.map(group => 
                data.filter(row => row[groupColumn] === group).map(row => row[valueColumn])
            );

            const grandMean = math.mean(data.map(row => row[valueColumn]));
            const totalSS = data.reduce((sum, row) => sum + Math.pow(row[valueColumn] - grandMean, 2), 0);
            
            const betweenSS = groupData.reduce((sum, group) => 
                sum + group.length * Math.pow(math.mean(group) - grandMean, 2), 0);
            
            const withinSS = totalSS - betweenSS;
            
            const dfBetween = groups.length - 1;
            const dfWithin = data.length - groups.length;
            const dfTotal = data.length - 1;
            
            const msBetween = betweenSS / dfBetween;
            const msWithin = withinSS / dfWithin;
            
            const fValue = msBetween / msWithin;
            const pValue = 1 - jstat.centralF.cdf(fValue, dfBetween, dfWithin);

            return {
                fValue: fValue,
                pValue: pValue,
                dfBetween: dfBetween,
                dfWithin: dfWithin,
                msBetween: msBetween,
                msWithin: msWithin,
                etaSquared: betweenSS / totalSS
            };
        }

        function calculateCorrelation() {
            const xVariable = document.getElementById('xVariable').value;
            const yVariable = document.getElementById('yVariable').value;
            
            const xValues = data.map(row => row[xVariable]);
            const yValues = data.map(row => row[yVariable]);
            
            const correlation = math.correlation(xValues, yValues);
            const rSquared = Math.pow(correlation, 2);
            
            return {
                correlation: correlation,
                rSquared: rSquared,
                xMean: math.mean(xValues),
                yMean: math.mean(yValues),
                xStd: math.std(xValues),
                yStd: math.std(yValues)
            };
        }

        function performRegression() {
            const xVariable = document.getElementById('xVariable').value;
            const yVariable = document.getElementById('yVariable').value;
            
            const xValues = data.map(row => row[xVariable]);
            const yValues = data.map(row => row[yVariable]);
            
            const regression = math.linearRegression(xValues, yValues);
            const slope = regression.slope;
            const intercept = regression.intercept;
            const rSquared = Math.pow(math.correlation(xValues, yValues), 2);
            
            return {
                slope: slope,
                intercept: intercept,
                rSquared: rSquared,
                equation: `y = ${slope.toFixed(4)}x + ${intercept.toFixed(4)}`,
                xMean: math.mean(xValues),
                yMean: math.mean(yValues),
                xStd: math.std(xValues),
                yStd: math.std(yValues)
            };
        }

        function performChiSquareTest() {
            const variable1 = document.getElementById('variable1').value;
            const variable2 = document.getElementById('variable2').value;
            
            const contingencyTable = {};
            data.forEach(row => {
                const val1 = row[variable1];
                const val2 = row[variable2];
                if (!contingencyTable[val1]) contingencyTable[val1] = {};
                contingencyTable[val1][val2] = (contingencyTable[val1][val2] || 0) + 1;
            });
            
            const rowTotals = {};
            const colTotals = {};
            let grandTotal = 0;
            
            Object.keys(contingencyTable).forEach(row => {
                Object.keys(contingencyTable[row]).forEach(col => {
                    const count = contingencyTable[row][col];
                    rowTotals[row] = (rowTotals[row] || 0) + count;
                    colTotals[col] = (colTotals[col] || 0) + count;
                    grandTotal += count;
                });
            });
            
            let chiSquare = 0;
            let df = 0;
            
            Object.keys(contingencyTable).forEach(row => {
                Object.keys(contingencyTable[row]).forEach(col => {
                    const observed = contingencyTable[row][col];
                    const expected = (rowTotals[row] * colTotals[col]) / grandTotal;
                    chiSquare += Math.pow(observed - expected, 2) / expected;
                });
            });
            
            df = (Object.keys(rowTotals).length - 1) * (Object.keys(colTotals).length - 1);
            const pValue = 1 - jstat.chisquare.cdf(chiSquare, df);
            
            return {
                chiSquare: chiSquare,
                degreesOfFreedom: df,
                pValue: pValue,
                contingencyTable: contingencyTable
            };
        }

        function performFactorAnalysis() {
            // Note: This is a simplified version of factor analysis
            const variables = Array.from(document.getElementById('variablesSelect').selectedOptions).map(option => option.value);
            const matrix = math.matrix(data.map(row => variables.map(v => row[v])));
            
            const correlationMatrix = math.correlation(matrix);
            const eigenvalues = math.eigs(correlationMatrix).values;
            
            return {
                correlationMatrix: correlationMatrix,
                eigenvalues: eigenvalues,
                // Additional factor analysis results would be calculated here
            };
        }

        function performMannWhitneyTest() {
            const groupColumn = document.getElementById('groupColumn').value;
            const valueColumn = document.getElementById('valueColumn').value;
            const groups = [...new Set(data.map(row => row[groupColumn]))];
            
            if (groups.length !== 2) {
                return "Mann-Whitney U test requires exactly two groups.";
            }

            const group1 = data.filter(row => row[groupColumn] === groups[0]).map(row => row[valueColumn]);
            const group2 = data.filter(row => row[groupColumn] === groups[1]).map(row => row[valueColumn]);

            const ranks = [...group1, ...group2].sort((a, b) => a - b)
                .map((value, index) => ({ value, rank: index + 1 }));

            const r1 = ranks.filter(r => group1.includes(r.value)).reduce((sum, r) => sum + r.rank, 0);
            const r2 = ranks.filter(r => group2.includes(r.value)).reduce((sum, r) => sum + r.rank, 0);

            const n1 = group1.length;
            const n2 = group2.length;

            const u1 = r1 - (n1 * (n1 + 1)) / 2;
            const u2 = r2 - (n2 * (n2 + 1)) / 2;

            const u = Math.min(u1, u2);
            const z = (u - (n1 * n2 / 2)) / Math.sqrt((n1 * n2 * (n1 + n2 + 1)) / 12);

            const pValue = 2 * (1 - jstat.normal.cdf(Math.abs(z), 0, 1));

            return {
                uStatistic: u,
                zScore: z,
                pValue: pValue,
                group1Median: math.median(group1),
                group2Median: math.median(group2)
            };
        }

        function performClusterAnalysis() {
            // Note: This is a simplified k-means clustering
            const variables = Array.from(document.getElementById('variablesSelect').selectedOptions).map(option => option.value);
            const k = 3; // Number of clusters (you might want to make this adjustable)
            
            const points = data.map(row => variables.map(v => row[v]));
            
            // Initialize centroids randomly
            let centroids = Array(k).fill().map(() => 
                variables.map(() => Math.random() * (math.max(points) - math.min(points)) + math.min(points))
            );
            
            const maxIterations = 100;
            let iterations = 0;
            let oldCentroids;
            
            do {
                oldCentroids = JSON.parse(JSON.stringify(centroids));
                
                // Assign points to clusters
                const clusters = Array(k).fill().map(() => []);
                points.forEach(point => {
                    const distances = centroids.map(centroid => 
                        math.distance(point, centroid)
                    );
                    const closestCentroidIndex = distances.indexOf(Math.min(...distances));
                    clusters[closestCentroidIndex].push(point);
                });
                
                // Update centroids
                centroids = clusters.map(cluster => 
                    variables.map((_, i) => math.mean(cluster.map(point => point[i])))
                );
                
                iterations++;
            } while (iterations < maxIterations && !arraysEqual(oldCentroids, centroids));
            
            return {
                clusters: centroids.map((_, i) => ({
                    centroid: centroids[i],
                    size: clusters[i].length
                })),
                iterations: iterations
            };
        }

        function arraysEqual(a, b) {
            return JSON.stringify(a) === JSON.stringify(b);
        }

        function updateChart(results, analysisType) {
            const ctx = document.getElementById('chartCanvas').getContext('2d');
            const chartType = document.getElementById('chartType').value;

            if (chart) {
                chart.destroy();
            }

            let chartData;
            let chartOptions;

            switch (analysisType) {
                case 'basic':
                    chartData = {
                        labels: Object.keys(results),
                        datasets: [{
                            label: 'Basic Statistics',
                            data: Object.values(results),
                            backgroundColor: 'rgba(255, 0, 255, 0.5)',
                            borderColor: 'rgba(255, 0, 255, 1)'
                        }]
                    };
                    break;
                case 'ttest':
                case 'mannwhitney':
                    chartData = {
                        labels: ['Group 1', 'Group 2'],
                        datasets: [{
                            label: 'Group Means',
                            data: [results.group1Statistics.mean, results.group2Statistics.mean],
                            backgroundColor: ['rgba(255, 0, 255, 0.5)', 'rgba(0, 255, 255, 0.5)'],
                            borderColor: ['rgba(255, 0, 255, 1)', 'rgba(0, 255, 255, 1)']
                        }]
                    };
                    break;
                case 'anova':
                    chartData = {
                        labels: ['Between Groups', 'Within Groups'],
                        datasets: [{
                            label: 'Mean Squares',
                            data: [results.msBetween, results.msWithin],
                            backgroundColor: ['rgba(255, 0, 255, 0.5)', 'rgba(0, 255, 255, 0.5)'],
                            borderColor: ['rgba(255, 0, 255, 1)', 'rgba(0, 255, 255, 1)']
                        }]
                    };
                    break;
                case 'correlation':
                case 'regression':
                    const xVariable = document.getElementById('xVariable').value;
                    const yVariable = document.getElementById('yVariable').value;
                    chartData = {
                        datasets: [{
                            label: 'Data Points',
                            data: data.map(row => ({x: row[xVariable], y: row[yVariable]})),
                            backgroundColor: 'rgba(255, 0, 255, 0.5)',
                            borderColor: 'rgba(255, 0, 255, 1)'
                        }]
                    };
                    chartOptions = {
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: xVariable
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: yVariable
                                }
                            }
                        }
                    };
                    break;
                case 'chisquare':
                    const categories1 = Object.keys(results.contingencyTable);
                    const categories2 = Object.keys(results.contingencyTable[categories1[0]]);
                    chartData = {
                        labels: categories1,
                        datasets: categories2.map(cat2 => ({
                            label: cat2,
                            data: categories1.map(cat1 => results.contingencyTable[cat1][cat2] || 0),
                            backgroundColor: `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, 0.5)`
                        }))
                    };
                    break;
                case 'factoranalysis':
                    chartData = {
                        labels: results.eigenvalues.map((_, i) => `Factor ${i+1}`),
                        datasets: [{
                            label: 'Eigenvalues',
                            data: results.eigenvalues,
                            backgroundColor: 'rgba(255, 0, 255, 0.5)',
                            borderColor: 'rgba(255, 0, 255, 1)'
                        }]
                    };
                    break;
                case 'cluster':
                    const variables = Array.from(document.getElementById('variablesSelect').selectedOptions).map(option => option.value);
                    if (variables.length === 2) {
                        chartData = {
                            datasets: results.clusters.map((cluster, i) => ({
                                label: `Cluster ${i+1}`,
                                data: [{x: cluster.centroid[0], y: cluster.centroid[1]}],
                                backgroundColor: `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, 0.5)`,
                                borderColor: `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, 1)`,
                                pointRadius: 10
                            }))
                        };
                        chartOptions = {
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: {
                                        display: true,
                                        text: variables[0]
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: variables[1]
                                    }
                                }
                            }
                        };
                    } else {
                        // For more than 2 variables, show cluster sizes
                        chartData = {
                            labels: results.clusters.map((_, i) => `Cluster ${i+1}`),
                            datasets: [{
                                label: 'Cluster Sizes',
                                data: results.clusters.map(cluster => cluster.size),
                                backgroundColor: 'rgba(255, 0, 255, 0.5)',
                                borderColor: 'rgba(255, 0, 255, 1)'
                            }]
                        };
                    }
                    break;
            }

            chart = new Chart(ctx, {
                type: chartType,
                data: chartData,
                options: {
                    ...chartOptions,
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                            }
                        }
                    }
                }
            });
        }

        function exportResults() {
            const results = document.getElementById('results').textContent;
            const blob = new Blob([results], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'analysis_results.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize UI
        function initializeUI() {
            // Set up file input
            const fileInput = document.getElementById('fileUpload');
            fileInput.addEventListener('change', processCSV);

            // Set up analysis type selector
            const analysisTypeSelect = document.getElementById('analysisType');
            analysisTypeSelect.addEventListener('change', updateUI);

            // Set up chart type selector
            const chartTypeSelect = document.getElementById('chartType');
            chartTypeSelect.addEventListener('change', updateChart);

            // Initialize dynamic inputs
            updateUI();

            // Set up run analysis button
            const runAnalysisButton = document.querySelector('button[onclick="runAnalysis()"]');
            runAnalysisButton.addEventListener('click', runAnalysis);

            // Set up export results button
            const exportResultsButton = document.querySelector('button[onclick="exportResults()"]');
            exportResultsButton.addEventListener('click', exportResults);

            // Initialize results display
            const resultsDiv = document.getElementById('results');
            resultsDiv.textContent = 'No analysis performed yet.';

            // Initialize chart
            const ctx = document.getElementById('chartCanvas').getContext('2d');
            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['No Data'],
                    datasets: [{
                        label: 'No Data',
                        data: [0],
                        backgroundColor: 'rgba(255, 0, 255, 0.5)',
                        borderColor: 'rgba(255, 0, 255, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                            }
                        }
                    }
                }
            });

            // Set up filter container
            const filterContainer = document.getElementById('filterContainer');
            filterContainer.innerHTML = '<p>No filters available yet.</p>';

            // Initialize tooltips
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        }

        // Call the initialization function when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initializeUI);

        function updateFileStatus(message) {
            document.getElementById('fileStatus').textContent = message;
        }
    </script>
</body>
</html>